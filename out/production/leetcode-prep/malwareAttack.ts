// class DSU {
//   components: number[];
//   constructor(size: number, existingComponent?: number[]) {
//     this.components = existingComponent || Array(size).fill(-1);
//   }

//   findParent(node: number): number {
//     //if the value is a negative number, then we have found a parent.
//     if (this.components[node] < 0) return node;
//     return this.findParent(this.components[node]);
//   }

//   union(node1: number, node2: number) {
//     const parentNode1 = this.findParent(node1);
//     const parentNode2 = this.findParent(node2);

//     if (parentNode1 !== parentNode2) {
//       const node2ComponetSize = this.components[parentNode2];
//       this.components[parentNode1] += node2ComponetSize;
//       this.components[parentNode2] = parentNode1;
//     }
//   }
// }

// function minimizeMalwareSpread(graph: number[][], infected: number[]) {
//   //Do all the connections with a DSV without the infected nodes
//   const dsu = new DSU(graph.length);
//   for (let i = 0; i < graph.length; i++) {
//     if (!infected.includes(i)) {
//       const node = graph[i];
//       for (let j = 0; j < node.length; j++) {
//         if (!infected.includes(j) && node[j] === 1) {
//           dsu.union(i, j);
//         }
//       }
//     }
//   }

//   //connect each infected node then check the value of the parent
//   //to determine how many nodes are affected.

//   // let maxNodes = 0;
//   // let nodeToRemove: number | null = 0;

//   // for(let i = 0; i < infected.length; i++) {
//   //   const freshDsu = new DSU(graph.length, [...dsu.components]);
//   //   const infectedNode = graph[infected[i]]
//   //   for(let j = 0; j < infectedNode.length; j++){
//   //     if((!infected.includes(j) && infectedNode[j] === 1)){
//   //       freshDsu.union(infected[i], j)
//   //       const affectedNodes = Math.abs(freshDsu.components[infected[i]])
//   //       if(affectedNodes > maxNodes) {
//   //         maxNodes = affectedNodes;
//   //         nodeToRemove = infected[i]
//   //       }
//   //     }
//   //   }
//   // }

//   //The one with the most is the answer
//   // return nodeToRemove

//   const cleanState = dsu.components;
//   let worstSize = 0;
//   let worstNode = null;

//   for (let i = 0; i < infected.length; i++) {
//     const freshDSU = new DSU(graph.length, [...cleanState]);
//     const infectedNode = infected[i];
//     const connections = graph[infectedNode];
//     for (let j = 0; j < connections.length; j++) {
//       if (infected.indexOf(j) > -1) continue;
//       if (connections[j]) {
//         freshDSU.union(infectedNode, j);
//       }
//     }

//     if (freshDSU.components[infectedNode] < worstSize) {
//       worstNode = infectedNode;
//     }
//     worstSize = Math.min(worstSize, freshDSU.components[infectedNode]);
//   }

//   return worstNode;
// }

// const dsv = new DSU(10);
// console.log(dsv.components);
// console.log(dsv.findParent(1));
// dsv.union(4, 5);
// console.log(dsv.components);
// dsv.union(6, 8);
// console.log(dsv.components);
// dsv.union(8, 5);
// console.log(dsv.components);
// dsv.union(0, 9);
// console.log(dsv.components);
// dsv.union(4, 4);
// console.log(dsv.components);

// console.log(
//   minimizeMalwareSpread(
//     [
//       [0, 1, 0, 0],
//       [1, 0, 1, 0],
//       [0, 1, 0, 1],
//       [0, 0, 1, 0],
//     ],
//     [0, 1]
//   )
// );
// console.log(
//   minimizeMalwareSpread(
//     [
//       [0, 1, 0],
//       [1, 0, 1],
//       [0, 1, 0],
//     ],
//     [0, 1]
//   )
// );
// console.log(
//   minimizeMalwareSpread(
//     [
//       [0, 1, 1],
//       [1, 0, 0],
//       [1, 0, 0],
//     ],
//     [0, 1]
//   )
// );
// console.log(
//   minimizeMalwareSpread(
//     [
//       [1, 0, 1, 0],
//       [0, 1, 0, 0],
//       [1, 0, 1, 0],
//       [0, 0, 0, 1],
//     ],
//     [1]
//   )
// );
// console.log(
//   minimizeMalwareSpread(
//     [
//       [1, 1, 0],
//       [1, 1, 0],
//       [0, 0, 1],
//     ],
//     [0, 1, 2]
//   )
// );
